/*
 * 2023-2055 (C) E. Bouchar√©
 */

#include "pin_mux.h"
#include "board.h"

#include "fsl_gpio.h"
#include "fsl_common.h"
#include "fsl_power.h"

/*******************************************************************************
 * Mailbox and events
 ******************************************************************************/
#define EVT_MASK						(0xFF<<24)

#define EVT_NONE						0
#define EVT_CORE_UP						(1U<<24)
#define EVT_RETVAL						(2U<<24)

/* mailbox communication between cores */
void mb_init(void)
{
//  Init already done by core0
	MAILBOX->MBOXIRQ[0].IRQCLR=0xFFFFFFFF;
    NVIC_SetPriority(MAILBOX_IRQn, 2);
    NVIC_EnableIRQ(MAILBOX_IRQn);
}

/* pop event from CPU0 */
uint32_t mb_pop_evt(void)
{
	uint32_t evt=MAILBOX->MBOXIRQ[0].IRQ;
	MAILBOX->MBOXIRQ[0].IRQCLR=evt;
	return evt;
}

/* send event to CPU1, wait if there is already a pending event, unless force is set */
bool mb_push_evt(uint32_t evt, bool force)
{
	if (MAILBOX->MBOXIRQ[1].IRQ && !force) {
		return false;
	}
	MAILBOX->MBOXIRQ[1].IRQSET=evt;
	return true;
}

#ifdef LCD_CORE1
#include "lcd.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

typedef enum {
	L_SOLID, L_DOTTED, L_DASHED, L_COMB, L_ARROW, L_BAR, L_FBAR,
	L_STEP, L_FSTEP, L_NONE
} line_t;

typedef enum {
	M_CROSS, M_PLUS, M_DOT, M_STAR, M_CIRCLE, M_FCIRCLE,
	M_SQUARE, M_FSQUARE, M_DIAMOND, M_FDIAMOND, M_ARROW,
	M_TRIANGLE, M_FTRIANGLE, M_NONE
} marker_t;

line_t		ltype=L_SOLID;
marker_t	mtype=M_NONE;
int			msize=6;

/*******************************************************************************
 * Mailbox and events
 ******************************************************************************/
#define EVT_DRAWPOINT					(3U<<24)
#define EVT_DRAWLINE					(4U<<24)
#define EVT_DRAWRECT					(5U<<24)
#define EVT_DRAWRNDRECT					(6U<<24)
#define EVT_DRAWCIRCLE					(7U<<24)
#define EVT_DRAWELLISPSE				(8U<<24)
#define EVT_DRAWLINES					(9U<<24)
#define EVT_DRAWSEGMENTS				(10U<<24)
#define EVT_FILLRECT					(11U<<24)
#define EVT_CLIP						(12U<<24)
#define EVT_UNCLIP						(13U<<24)
#define EVT_DRAWPATH					(14U<<24)

#define EVT_FORECOLOR					(15U<<24)
#define EVT_BACKCOLOR					(16U<<24)
#define EVT_SETFONT						(17U<<24)

#define EVT_SETALIGNMENT				(18U<<24)
#define EVT_SETDIRECTION				(19U<<24)
#define EVT_DRAWSTRING					(20U<<24)

#define EVT_GETBUFFER					(30U<<24)

/* event queue */
#define MAX_EVT_DATA				5
typedef struct _Event {
	uint32_t	event;
	uint32_t	data[MAX_EVT_DATA];
} Event;

/* event queue handling */
#define MAX_EVTS					20

volatile Event evq[MAX_EVTS];
volatile int evq_rd=0, evq_wr=0;

bool next_event(Event *evt)
{
	if (evq_rd==evq_wr) return false;

	*evt=evq[evq_rd];
	evq_rd=(evq_rd+1) % MAX_EVTS;
	return true;
}

void MAILBOX_IRQHandler(void)
{
	if (((evq_wr+1)%MAX_EVTS)!=evq_rd) {
		evq[evq_wr].event = mb_pop_evt();
		evq_wr=(evq_wr+1) % MAX_EVTS;
	}
}

/*******************************************************************************
 * shared buffer
 ******************************************************************************/
#define MAXPOINTS	2048
#define BUFFERSIZE  256
#define POOLSIZE    10
#define ASYNCMODE   0

//_attribute_ ((section(".shmem")))
//SPoint shdata[MAXPOINTS];				/* shared data buffer */
extern SPoint __start_noinit_shmem[];
SPoint *shdata=__start_noinit_shmem;

#if ASYNCMODE

typedef struct DataPool{
    volatile uint8_t inUse;          // 0 = free, 1 = busy
    char data[BUFFERSIZE];
} DataPool;

volatile DataPool *pool = (DataPool *)(__start_noinit_shmem + MAXPOINTS);

void init_pool(void)
{
    for (int i = 0; i < POOLSIZE; i++) {
    	pool[i].inUse = 0;
    }
}

void free_buffer(int id) {
	if(id < POOLSIZE)
		pool[id].inUse = 0;
}

#endif
/*******************************************************************************
 * main
 ******************************************************************************/
int main(void)
{
    /* Init board hardware.*/
	lcd_init();
	lcd_switch_to(LCD_DPY);
    /* Initialize mailbox, send EVT_CORE_UP to notify core 0 that core 1 is up
     * and ready to work.
     */
	mb_init();
    mb_push_evt(EVT_CORE_UP,true);

#if ASYNCMODE
    init_pool();
#endif

	Event ev;
 	short x0, x1, y0, y1, w, h;
 	int n;
   	DC dc;
 	uint16_t alignment;
 	uint8_t direction;
 	Font* font;
 	uint32_t tmp;
 	int idx;
   	lcd_get_default_DC(&dc);

    for (;;) {
    	while (!next_event(&ev)) {}
    	switch (ev.event & EVT_MASK) {

#if ASYNCMODE

    	case EVT_FORECOLOR:
			idx = (ev.event &0x00FF0000)>>16;
    		dc.fcolor = (uint16_t)pool[idx].data[0] | ((uint16_t)pool[idx].data[1] << 8);
    		free_buffer(idx);
			break;


    	case EVT_DRAWRECT:
			idx = (ev.event &0x00FF0000)>>16;

			uint16_t x0 = (uint16_t)pool[idx].data[0] | ((uint16_t)pool[idx].data[1] << 8);
			uint16_t y0 = (uint16_t)pool[idx].data[2] | ((uint16_t)pool[idx].data[3] << 8);
			uint16_t w  = (uint16_t)pool[idx].data[4] | ((uint16_t)pool[idx].data[5] << 8);
			uint16_t h  = (uint16_t)pool[idx].data[6] | ((uint16_t)pool[idx].data[7] << 8);

			lcd_draw_rect(x0, y0, w, h, dc.fcolor);
			free_buffer(idx);
    		break;


    	case EVT_CLIP:
			idx = (ev.event &0x00FF0000)>>16;

    	    x0 = (uint16_t)pool[idx].data[0] | ((uint16_t)pool[idx].data[1] << 8);
    	    y0 = (uint16_t)pool[idx].data[2] | ((uint16_t)pool[idx].data[3] << 8);
    	    x1 = (uint16_t)pool[idx].data[4] | ((uint16_t)pool[idx].data[5] << 8);
    	    y1 = (uint16_t)pool[idx].data[6] | ((uint16_t)pool[idx].data[7] << 8);

    	    lcd_clip(x0, y0, x1, y1);

    	    free_buffer(idx);
    	    break;

    	case EVT_SETFONT:
    		font=(Font * )(ev.event&0xFFFFFFFF);
    		lcd_set_font(&dc,font);
    		break;



    	case EVT_SETALIGNMENT:
			idx = (ev.event &0x00FF0000)>>16;
			tmp = (uint32_t)pool[idx].data[0] | ((uint32_t)pool[idx].data[1] << 8) | ((uint32_t)pool[idx].data[2] << 16) | ((uint32_t)pool[idx].data[3] << 24);
			lcd_set_alignment(&dc, tmp);
			free_buffer(idx);
			break;



    	case EVT_SETDIRECTION:
    		idx = (ev.event &0x00FF0000)>>16;
			tmp = (uint32_t)pool[idx].data[0] | ((uint32_t)pool[idx].data[1] << 8) | ((uint32_t)pool[idx].data[2] << 16) | ((uint32_t)pool[idx].data[3] << 24);
			lcd_set_direction(&dc, tmp);
			free_buffer(idx);
			break;

    	case EVT_DRAWSTRING:
    	{
    		idx = (ev.event &0x00FF0000)>>16;
    	    int n   = ev.event & 0xFFFF;

    	    uint16_t x0 = (uint16_t)pool[idx].data[0] | ((uint16_t)pool[idx].data[1] << 8);
    	    uint16_t y0 = (uint16_t)pool[idx].data[2] | ((uint16_t)pool[idx].data[3] << 8);

    	    char *my_str = (char *)malloc(n + 1);
    	    if (my_str) {
    	        int offset = 4;
    	        int str_index = 0;
    	        while (str_index < n) {
    	            my_str[str_index++] = (char)(pool[idx].data[offset++] & 0xFF);
    	            if (str_index < n)
    	                my_str[str_index++] = (char)(pool[idx].data[offset++] & 0xFF);
    	            else
    	                break;
    	        }
    	        my_str[n] = '\0';
    	        lcd_draw_string(&dc, x0, y0, my_str);
    	        free(my_str);
    	    }

    	    free_buffer(idx);
    	    break;
    	}



    	case EVT_FILLRECT:
			idx = (ev.event &0x00FF0000)>>16;
			  x0 = (uint16_t)pool[idx].data[0] | ((uint16_t)pool[idx].data[1] << 8);
			 y0 = (uint16_t)pool[idx].data[2] | ((uint16_t)pool[idx].data[3] << 8);
			 w = (uint16_t)pool[idx].data[4] | ((uint16_t)pool[idx].data[5] << 8);
			 h = (uint16_t)pool[idx].data[6] | ((uint16_t)pool[idx].data[7] << 8);

			lcd_fill_rect(x0, y0, w, h, dc.fcolor);
			free_buffer(idx);
			break;

#else
		case EVT_FORECOLOR:
			dc.fcolor=(Color)(ev.event & 0x0000FFFF);
			mb_push_evt(EVT_RETVAL,true);
			break;

		case EVT_DRAWRECT:

			x0=shdata[0].x;
			y0=shdata[0].y;
			w=shdata[1].x;
			h=shdata[1].y;
			lcd_draw_rect(x0, y0, w, h,dc.fcolor);
			mb_push_evt(EVT_RETVAL,true);

			break;

		case EVT_CLIP:
			x0=shdata[0].x;
			y0=shdata[0].y;
			x1=shdata[1].x;
			y1=shdata[1].y;
			lcd_clip(x0,y0,x1, y1);
			mb_push_evt(EVT_RETVAL,true);
			break;

		case EVT_SETALIGNMENT:
			alignment=ev.event&0x00000FFF;
			lcd_set_alignment(&dc,alignment);
			mb_push_evt(EVT_RETVAL,true);
			break;

		case EVT_SETDIRECTION:
			direction=ev.event&0x000000FF;
			lcd_set_direction(&dc,direction);
			mb_push_evt(EVT_RETVAL,true);
			break;

    	case EVT_DRAWSTRING: {
    	    x0 = shdata[0].x;
    	    y0 = shdata[0].y;
    	    n = ev.event & 0xFFFF;

    	    int dataIndex = 1;
    	    char *my_str = (char *)malloc(n + 1);  // +1 for null terminator
    	    if (my_str != NULL) {
    	        int str_index = 0;
    	        for (int str_index = 0; str_index < n; str_index += 2) {
    	            my_str[str_index] = (char)((uint8_t)shdata[dataIndex].x);
    	            if ((str_index + 1) < n)
    	                my_str[str_index + 1] = (char)((uint8_t)shdata[dataIndex].y);
    	            dataIndex++;
    	        }
    	        my_str[n] = '\0';
    	    } else {
    	        my_str = "";
    	    }

    	    lcd_draw_string(&dc, x0, y0, my_str);
    	    mb_push_evt(EVT_RETVAL, true);

    	    if (my_str != NULL && my_str != "") {
    	        free(my_str);
    	    }
    	    break;
    	}

		case EVT_FILLRECT:
			x0 = shdata[0].x;
			y0 = shdata[0].y;
			w = shdata[1].x;
			h = shdata[1].y;

			lcd_fill_rect(x0, y0, w, h, dc.fcolor);

			mb_push_evt(EVT_RETVAL, true);

			break;

#endif

		case EVT_UNCLIP:
			lcd_unclip();
			break;

    	case EVT_DRAWSEGMENTS:
			n=ev.event&0xFFF;
			for (int i=1;i<n;i++) {
				x0=shdata[2*i].x;
				y0=shdata[2*i].y;
				x1=shdata[2*i+1].x;
				y1=shdata[2*i+1].y;
				lcd_line(x0, y0,x1,y1, dc.fcolor);
    		}
			mb_push_evt(EVT_RETVAL, true);
		break;
    	default:
    		break;
    	}
    }
}
#else
/*******************************************************************************
 * TEST APP: BLINK A LED
 ******************************************************************************/
#define LED_INIT()                   \
    gpio_pin_config_t led_config = { \
        kGPIO_DigitalOutput,         \
        0,                           \
    };                               \
    GPIO_PinInit(GPIO, BOARD_LED_RED_GPIO_PORT, BOARD_LED_RED_GPIO_PIN, &led_config);
#define LED_TOGGLE() GPIO_PortToggle(GPIO, BOARD_LED_RED_GPIO_PORT, 1u << BOARD_LED_RED_GPIO_PIN);

/*******************************************************************************
 * main
 ******************************************************************************/
int main(void)
{
    /* Initialize mailbox, send EVT_CORE_UP to notify core 0 that core 1 is up
     * and ready to work.
     */
  	mb_init();
    mb_push_evt(EVT_CORE_UP,true);

    /* enable clock for GPIO */
    CLOCK_EnableClock(kCLOCK_Gpio0);
    CLOCK_EnableClock(kCLOCK_Gpio1);
    BOARD_InitBootPins();
   /* Make a noticable delay after the reset */
    /* Use startup parameter from the master core... */
    for (int i = 0; i < 2; i++)
    {
        SDK_DelayAtLeastUs(1000000U, 150000000L);
    }

    /* Configure LED */
    LED_INIT();

    for (;;)
    {
        SDK_DelayAtLeastUs(500000U, 150000000L);
        LED_TOGGLE();
    }
    return 0;
}
#endif
